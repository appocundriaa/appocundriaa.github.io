<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Marco Marino</title>

  <!-- General Sans -->
  <link href="https://api.fontshare.com/v2/css?f[]=general-sans@400,500,600,700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css" />
</head>

<body class="default">

  <header class="header">
    <div class="header-grid">
      <div class="spacer"></div>

      <div class="header-content">

        <p id="bioSource" class="sr-only">
È un Sironi! Tra i più famosi. Pubblicato su tutti i cataloghi. È del periodo pessimista! Il più raro. Questo se t'o attacchi in ufficio c'hai uno scatto da così a così! Te lo metti in casa, fai un figurone! Io ce l'ho avuto in salotto per vent'anni, tu non sai quanto m'ha aiutato a me, le serate che m'ha risolto... perché è anche un argomento di conversazione, sai? C'è pure chi dice: se c'ha 'e zinne viola, de che colore c'avrà er culo?
        </p>

        <div class="bio-circle" aria-label="Bio">
          <div id="bioCircleLines" class="bio-circle__lines"></div>
        </div>

        <div class="contact-wrapper">
          <p class="role">Editor, writer, historian &amp;c.</p>
          <div class="contact-link-wrapper">
            <a class="link" href="mailto:mmarino1@iuav.it">mmarino1@iuav.it</a>
            <span class="sep">|</span>
            <a class="link" href="https://www.instagram.com/appocundriaa/" target="_blank" rel="noreferrer">
              @appocundriaa ↗
            </a>
            <span class="sep">|</span>
            <a class="link" href="#" target="_blank" rel="noreferrer">substack.com ↗</a>
          </div>
        </div>

        <section class="filters" id="filters" aria-label="Filtri">
          <div class="filter-stack" id="filterStack">

            <svg class="filter-connector" viewBox="0 0 100 100" preserveAspectRatio="none" aria-hidden="true">
              <path id="filterConnectorPath" d="" fill="none"></path>
            </svg>

            <div class="filter-group" id="categoryGroup">
              <button class="pill" data-filter="Essay" type="button">Essay</button>
              <button class="pill" data-filter="Speaking" type="button">Speaking</button>
              <button class="pill" data-filter="Editing" type="button">Editing</button>
              <button class="pill is-active" data-filter="Journalism" type="button">Journalism</button>
            </div>

            <div class="filter-group" id="tagGroup">
              <button class="pill is-active" data-filter="Fashion" type="button">Fashion</button>
              <button class="pill" data-filter="Art" type="button">Art</button>
              <button class="pill" data-filter="Culture" type="button">Culture</button>
              <button class="pill" data-filter="Design" type="button">Design</button>
              <button class="pill" data-filter="History" type="button">History</button>
            </div>

          </div>
        </section>

      </div>

      <div class="spacer"></div>
    </div>
  </header>

  <main class="page-content">
    <section class="work-grid" aria-label="Lavori">
      <article class="work-row" data-category="Journalism" data-tags="Fashion,Design">
        <div class="work-year">2025</div>
        <div class="work-title">
          <a class="work-link" href="#" target="_blank" rel="noreferrer">
            Behind the Campaign @ Miu Miu with Lengua ↗
          </a>
        </div>
        <div class="work-spacer"></div>
      </article>

      <article class="work-row" data-category="Journalism" data-tags="Fashion,Design">
        <div class="work-year">2025</div>
        <div class="work-title">
          <a class="work-link" href="#" target="_blank" rel="noreferrer">
            An Interview with Evan Kinori @ 1 Granary ↗
          </a>
        </div>
        <div class="work-spacer"></div>
      </article>

      <article class="work-row" data-category="Journalism" data-tags="Fashion,Culture">
        <div class="work-year">2025</div>
        <div class="work-title">
          <a class="work-link" href="#" target="_blank" rel="noreferrer">
            Trend Forecasters on Predicting the Future @ 1 Granary ↗
          </a>
        </div>
        <div class="work-spacer"></div>
      </article>
    </section>

    <footer class="footer">
      <p>© 2026 – Marco Marino</p>
    </footer>

    <script>
      // ------------------------------------------------------------
      // CERCHIO: riempie ogni riga fino alla corda del cerchio (word-spacing dinamico)
      // così l'occhio vede un bordo circolare, non un rombo.
      // ------------------------------------------------------------
      (function renderCircleJustified() {
        const sourceEl = document.getElementById('bioSource');
        const outEl = document.getElementById('bioCircleLines');
        if (!sourceEl || !outEl) return;

        const text = (sourceEl.textContent || '').trim().replace(/\s+/g, ' ');
        const words = text.split(' ').filter(Boolean);
        if (!words.length) return;

        const ctx = document.createElement('canvas').getContext('2d');

        function maxWidthAtY(r, y) {
          const half = Math.sqrt(Math.max(0, (r * r) - (y * y)));
          return Math.max(0, 2 * half);
        }

        function measure(str, font) {
          ctx.font = font;
          return ctx.measureText(str).width;
        }

        function layout(diameter, fs, lh) {
          const padding = 10;
          const r = (diameter / 2) - padding;

          const linesCount = Math.max(30, Math.floor((2 * r) / lh)); // TANTE righe = più cerchio
          const yStart = -r + (lh / 2);

          const font = `600 ${fs}px "General Sans", Arial, sans-serif`;

          const lines = [];
          let idx = 0;

          for (let i = 0; i < linesCount; i++) {
            const y = yStart + i * lh;
            const maxW = maxWidthAtY(r, y);

            // poli: lascia righe vuote/strettissime per arrotondare
            if (maxW < fs * 2.8) {
              lines.push({ w: maxW, text: "", spaces: 0, fs, lh, justify: false });
              continue;
            }

            let lineWords = [];
            while (idx < words.length) {
              const candidate = lineWords.length ? [...lineWords, words[idx]] : [words[idx]];
              const candidateStr = candidate.join(' ');
              const w = measure(candidateStr, font);

              if (w <= maxW) {
                lineWords = candidate;
                idx++;
              } else {
                break;
              }
            }

            if (!lineWords.length && idx < words.length) {
              lineWords = [words[idx++]]; // fallback
            }

            const str = lineWords.join(' ');
            const spaces = Math.max(0, lineWords.length - 1);

            lines.push({
              w: maxW,
              text: str,
              spaces,
              fs,
              lh,
              // giustifica SOLO se ci sono abbastanza spazi e non è l'ultima riga di testo
              justify: spaces >= 2
            });

            if (idx >= words.length) {
              // riempi il resto con righe vuote per completare il cerchio
              for (let j = i + 1; j < linesCount; j++) {
                const y2 = yStart + j * lh;
                const maxW2 = maxWidthAtY(r, y2);
                lines.push({ w: maxW2, text: "", spaces: 0, fs, lh, justify: false });
              }
              break;
            }
          }

          const overflow = idx < words.length;
          return { lines, overflow, fs, lh, diameter };
        }

        function render(result) {
          const container = outEl.closest('.bio-circle');
          container.style.setProperty('--bio-d', `${result.diameter}px`);

          outEl.style.setProperty('--bio-fs', `${result.fs}px`);
          outEl.style.setProperty('--bio-lh', `${result.lh}px`);

          outEl.innerHTML = "";

          const font = `600 ${result.fs}px "General Sans", Arial, sans-serif`;

          // trova l'ultima riga non-vuota per NON giustificarla (come nei libri)
          let lastTextIndex = -1;
          result.lines.forEach((ln, i) => { if (ln.text) lastTextIndex = i; });

          result.lines.forEach((ln, i) => {
            const div = document.createElement('div');
            div.className = 'bio-line';
            div.style.width = `${ln.w}px`;

            if (!ln.text) {
              div.innerHTML = "&nbsp;";
              outEl.appendChild(div);
              return;
            }

            // calcola word-spacing per arrivare quasi a ln.w
            // (solo se non è l'ultima riga di testo)
            const shouldJustify = ln.justify && i !== lastTextIndex;

            if (shouldJustify) {
              const rawW = measure(ln.text, font);
              const diff = ln.w - rawW;

              // distribuisci il diff sugli spazi, clamp per non sfasciare
              const ws = Math.max(0, Math.min(6, diff / ln.spaces));
              div.style.wordSpacing = `${ws}px`;
            } else {
              div.style.wordSpacing = `0px`;
            }

            div.textContent = ln.text;
            outEl.appendChild(div);
          });
        }

        // Diametro più vicino reference + meno "vuoto"
        let diameter = Math.min(420, Math.floor(window.innerWidth * 0.86));

        // Ricerca font size: deve entrare tutto e riempire bene
        // Proviamo piccoli -> cerchio più liscio
        let best = null;

        for (let fs = 10.5; fs <= 13; fs += 0.25) {
          const lh = fs + 2.0;
          const r = layout(diameter, fs, lh);
          if (r.overflow) continue;

          // score: preferisci più righe "con testo" (meno vuoti)
          const textLines = r.lines.filter(x => x.text).length;
          const score = -textLines;

          if (!best || score < best.score) best = { ...r, score };
        }

        if (!best) {
          // fallback
          best = layout(diameter, 11.5, 13.5);
        }

        render(best);
      })();

      // ------------------------------------------------------------
      // FILTRI + freccia
      // ------------------------------------------------------------
      (function filtersAndConnector() {
        const state = { category: 'Journalism', tag: 'Fashion' };
        const categoryGroup = document.getElementById('categoryGroup');
        const tagGroup = document.getElementById('tagGroup');

        const normTags = (raw) => (raw || '').split(',').map(s => s.trim()).filter(Boolean);

        const setActive = (groupEl, value) => {
          groupEl.querySelectorAll('.pill').forEach(btn => {
            btn.classList.toggle('is-active', btn.dataset.filter === value);
          });
        };

        const updateList = () => {
          document.querySelectorAll('.work-row').forEach((row) => {
            const c = row.getAttribute('data-category') || '';
            const tags = normTags(row.getAttribute('data-tags'));
            row.style.display = (c === state.category && tags.includes(state.tag)) ? '' : 'none';
          });
        };

        const onClick = (groupEl, key) => {
          groupEl.addEventListener('click', (e) => {
            const btn = e.target.closest('button[data-filter]');
            if (!btn) return;
            state[key] = btn.dataset.filter;
            setActive(groupEl, state[key]);
            updateList();
            drawConnector();
          });
        };

        onClick(categoryGroup, 'category');
        onClick(tagGroup, 'tag');
        setActive(categoryGroup, state.category);
        setActive(tagGroup, state.tag);
        updateList();

        const stackEl = document.getElementById('filterStack');
        const path = document.getElementById('filterConnectorPath');

        function centerOf(el) {
          const r = el.getBoundingClientRect();
          return { x: r.left + r.width / 2, y: r.top + r.height / 2 };
        }

        function drawConnector() {
          const a = categoryGroup.querySelector('.pill.is-active');
          const b = tagGroup.querySelector('.pill.is-active');
          if (!a || !b) { path.setAttribute('d', ''); return; }

          const fr = stackEl.getBoundingClientRect();
          const p1 = centerOf(a);
          const p2 = centerOf(b);

          const x1 = ((p1.x - fr.left) / fr.width) * 100;
          const y1 = ((p1.y - fr.top) / fr.height) * 100;
          const x2 = ((p2.x - fr.left) / fr.width) * 100;
          const y2 = ((p2.y - fr.top) / fr.height) * 100;

          // “hand-drawn”: S più stretta con 2 gobbe
          const midX = (x1 + x2) / 2;
          const midY = (y1 + y2) / 2;

          const d = `
            M ${x1} ${y1}
            C ${x1 + 8} ${midY - 12},
              ${midX - 14} ${midY + 12},
              ${midX} ${midY}
            C ${midX + 14} ${midY - 12},
              ${x2 - 8} ${midY + 12},
              ${x2} ${y2}
          `;
          path.setAttribute('d', d);
        }

        window.addEventListener('resize', drawConnector);
        drawConnector();
      })();
    </script>

  </main>
</body>
</html>
